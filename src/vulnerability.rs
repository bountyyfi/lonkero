// Copyright (c) 2025 Bountyy Oy. All rights reserved.
// This software is proprietary and confidential.

use crate::http_client::HttpResponse;
use crate::types::{Confidence, Severity, Vulnerability};
use chrono::Utc;

pub struct VulnerabilityDetector;

impl VulnerabilityDetector {
    pub fn new() -> Self {
        Self
    }

    /// Detect XSS vulnerability
    pub fn detect_xss(
        &self,
        url: &str,
        parameter: &str,
        payload: &str,
        response: &HttpResponse,
    ) -> Option<Vulnerability> {
        // Check if payload is reflected in response
        if !response.contains(payload) {
            return None;
        }

        // Check for script execution indicators
        let has_script_tag = response.contains("<script") || response.contains("</script>");
        let has_event_handler = response.contains("onerror=") || response.contains("onload=");
        let has_javascript_protocol = response.contains("javascript:");

        let (severity, confidence) = if has_script_tag || has_event_handler || has_javascript_protocol {
            (Severity::High, Confidence::High)
        } else {
            (Severity::Medium, Confidence::Medium)
        };

        Some(Vulnerability {
            id: format!("xss_{}", uuid::Uuid::new_v4().to_string()),
            vuln_type: "Cross-Site Scripting (XSS)".to_string(),
            severity,
            confidence,
            category: "Injection".to_string(),
            url: url.to_string(),
            parameter: Some(parameter.to_string()),
            payload: payload.to_string(),
            description: format!(
                "Reflected XSS vulnerability detected in parameter '{}'. The application reflects user input without proper sanitization.",
                parameter
            ),
            evidence: Some(format!(
                "Payload '{}' was reflected in the response",
                payload
            )),
            cwe: "CWE-79".to_string(),
            cvss: 7.5,
            verified: true,
            false_positive: false,
            remediation: "1. Implement output encoding/escaping for all user input\n2. Use Content Security Policy (CSP) headers\n3. Enable X-XSS-Protection header\n4. Validate and sanitize all input server-side".to_string(),
            discovered_at: Utc::now().to_rfc3339(),
        })
    }

    /// Detect SQL injection vulnerability
    pub fn detect_sqli(
        &self,
        url: &str,
        parameter: &str,
        payload: &str,
        response: &HttpResponse,
        baseline_response: &HttpResponse,
    ) -> Option<Vulnerability> {
        // SQL error patterns
        let sql_errors = vec![
            "SQL syntax",
            "mysql_fetch",
            "ORA-",
            "PostgreSQL",
            "Microsoft SQL Server",
            "SQLite",
            "syntax error",
            "Warning: mysql",
            "pg_query",
            "mysqli",
            "SQLSTATE",
            "SQL Server",
            "OleDbException",
            "SqlException",
            "PDOException",
        ];

        // Check for SQL errors
        let has_sql_error = sql_errors
            .iter()
            .any(|pattern| response.body.contains(pattern));

        // Check for significant changes in response
        let size_diff = (response.body.len() as i64 - baseline_response.body.len() as i64).abs();
        let significant_change = size_diff > 100;

        let (severity, confidence) = if has_sql_error {
            (Severity::Critical, Confidence::High)
        } else if significant_change {
            (Severity::High, Confidence::Medium)
        } else {
            return None;
        };

        Some(Vulnerability {
            id: format!("sqli_{}", uuid::Uuid::new_v4().to_string()),
            vuln_type: "SQL Injection".to_string(),
            severity,
            confidence,
            category: "Injection".to_string(),
            url: url.to_string(),
            parameter: Some(parameter.to_string()),
            payload: payload.to_string(),
            description: format!(
                "SQL injection vulnerability detected in parameter '{}'. The application does not properly sanitize database queries.",
                parameter
            ),
            evidence: if has_sql_error {
                Some("SQL error detected in response".to_string())
            } else {
                Some(format!("Significant response change detected: {} bytes", size_diff))
            },
            cwe: "CWE-89".to_string(),
            cvss: 9.8,
            verified: true,
            false_positive: false,
            remediation: "1. Use parameterized queries/prepared statements\n2. Implement input validation and sanitization\n3. Apply principle of least privilege for database accounts\n4. Use an ORM framework".to_string(),
            discovered_at: Utc::now().to_rfc3339(),
        })
    }

    /// Detect command injection vulnerability
    pub fn detect_command_injection(
        &self,
        url: &str,
        parameter: &str,
        payload: &str,
        response: &HttpResponse,
    ) -> Option<Vulnerability> {
        // Command execution indicators
        let command_indicators = vec![
            "root:",
            "daemon:",
            "/bin/",
            "/usr/bin/",
            "uid=",
            "gid=",
            "groups=",
        ];

        let has_command_output = command_indicators
            .iter()
            .any(|pattern| response.body.contains(pattern));

        if !has_command_output {
            return None;
        }

        Some(Vulnerability {
            id: format!("cmdi_{}", uuid::Uuid::new_v4().to_string()),
            vuln_type: "Command Injection".to_string(),
            severity: Severity::Critical,
            confidence: Confidence::High,
            category: "Injection".to_string(),
            url: url.to_string(),
            parameter: Some(parameter.to_string()),
            payload: payload.to_string(),
            description: format!(
                "Command injection vulnerability detected in parameter '{}'. The application allows execution of arbitrary system commands.",
                parameter
            ),
            evidence: Some("System command output detected in response".to_string()),
            cwe: "CWE-78".to_string(),
            cvss: 9.8,
            verified: true,
            false_positive: false,
            remediation: "1. Avoid executing system commands with user input\n2. Use parameterized APIs when possible\n3. Implement strict input validation\n4. Use allowlists for permitted commands".to_string(),
            discovered_at: Utc::now().to_rfc3339(),
        })
    }
}

// Add uuid crate for generating IDs
mod uuid {
    use rand::Rng;

    pub struct Uuid;

    impl Uuid {
        pub fn new_v4() -> Self {
            Self
        }

        pub fn to_string(&self) -> String {
            let mut rng = rand::rng();
            format!(
                "{:08x}-{:04x}-{:04x}-{:04x}-{:012x}",
                rng.random::<u32>(),
                rng.random::<u16>(),
                rng.random::<u16>(),
                rng.random::<u16>(),
                rng.random::<u64>() & 0xffffffffffff
            )
        }
    }
}
