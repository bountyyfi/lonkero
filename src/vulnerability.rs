// Copyright (c) 2026 Bountyy Oy. All rights reserved.
// This software is proprietary and confidential.

use crate::http_client::HttpResponse;
use crate::types::{Confidence, Severity, Vulnerability};
use chrono::Utc;

pub struct VulnerabilityDetector;

impl VulnerabilityDetector {
    pub fn new() -> Self {
        Self
    }

    /// Detect XSS vulnerability
    pub fn detect_xss(
        &self,
        url: &str,
        parameter: &str,
        payload: &str,
        response: &HttpResponse,
    ) -> Option<Vulnerability> {
        // Check if payload is reflected in response
        if !response.contains(payload) {
            return None;
        }

        // Check for script execution indicators
        let has_script_tag = response.contains("<script") || response.contains("</script>");
        let has_event_handler = response.contains("onerror=") || response.contains("onload=");
        let has_javascript_protocol = response.contains("javascript:");

        let (severity, confidence) =
            if has_script_tag || has_event_handler || has_javascript_protocol {
                (Severity::High, Confidence::High)
            } else {
                (Severity::Medium, Confidence::Medium)
            };

        Some(Vulnerability {
            id: format!("xss_{}", uuid::Uuid::new_v4().to_string()),
            vuln_type: "Cross-Site Scripting (XSS)".to_string(),
            severity,
            confidence,
            category: "Injection".to_string(),
            url: url.to_string(),
            parameter: Some(parameter.to_string()),
            payload: payload.to_string(),
            description: format!(
                "Reflected XSS vulnerability detected in parameter '{}'. The application reflects user input without proper sanitization.",
                parameter
            ),
            evidence: Some(format!(
                "Payload '{}' was reflected in the response",
                payload
            )),
            cwe: "CWE-79".to_string(),
            cvss: 7.5,
            verified: true,
            false_positive: false,
            remediation: "1. Implement output encoding/escaping for all user input\n2. Use Content Security Policy (CSP) headers\n3. Enable X-XSS-Protection header\n4. Validate and sanitize all input server-side".to_string(),
            discovered_at: Utc::now().to_rfc3339(),
            ml_data: None,
        })
    }

    /// Detect SQL injection vulnerability
    pub fn detect_sqli(
        &self,
        url: &str,
        parameter: &str,
        payload: &str,
        response: &HttpResponse,
        baseline_response: &HttpResponse,
    ) -> Option<Vulnerability> {
        // HIGH-CONFIDENCE SQL error patterns - database-specific (case-insensitive)
        // These are VERY unlikely to appear in non-SQL contexts
        let high_confidence_errors = vec![
            // MySQL specific
            "you have an error in your sql syntax",
            "mysql_fetch",
            "mysqli_",
            "mysql_query",
            "mysql error",
            "warning: mysql",
            // PostgreSQL specific
            "pg_query",
            "pg_exec",
            "postgresql error",
            "psql:",
            // Oracle specific
            "ora-00",
            "ora-01",
            "ora-06",
            "ora-12",
            "oracle error",
            // SQL Server specific
            "microsoft sql server",
            "mssql_query",
            "sqlsrv_query",
            "oledbexception",
            "incorrect syntax near",
            // SQLite specific
            "sqlite3::",
            "sqlite_",
            "sqlite.exception",
            // Generic but specific to SQL
            "sqlstate[",
            "pdoexception",
            "sqlexception",
            "unclosed quotation mark",
            "quoted string not properly terminated",
            "unterminated quoted string",
            "unknown column '",
            "table doesn't exist",
            "no such table:",
            "no such column:",
            "column count doesn't match",
            "division by zero in sql",
        ];

        // MEDIUM-CONFIDENCE patterns - require additional context validation
        // These could appear in documentation/tutorials
        let medium_confidence_errors = vec![
            "sql error",
            "database error",
            "query failed",
            "invalid query",
        ];

        // Convert responses to lowercase for case-insensitive matching
        let response_lower = response.body.to_lowercase();
        let baseline_lower = baseline_response.body.to_lowercase();

        // Check for HIGH-CONFIDENCE SQL errors that are NEW (not in baseline)
        let has_high_confidence_error = high_confidence_errors.iter().any(|pattern| {
            response_lower.contains(pattern) && !baseline_lower.contains(pattern)
        });

        // If we have a high-confidence error, report it
        if has_high_confidence_error {
            let detected_error = high_confidence_errors
                .iter()
                .find(|pattern| {
                    response_lower.contains(*pattern) && !baseline_lower.contains(*pattern)
                })
                .map(|s| s.to_string())
                .unwrap_or_else(|| "SQL error pattern".to_string());

            return Some(Vulnerability {
                id: format!("sqli_{}", uuid::Uuid::new_v4().to_string()),
                vuln_type: "SQL Injection".to_string(),
                severity: Severity::Critical,
                confidence: Confidence::High,
                category: "Injection".to_string(),
                url: url.to_string(),
                parameter: Some(parameter.to_string()),
                payload: payload.to_string(),
                description: format!(
                    "SQL injection vulnerability detected in parameter '{}'. The application does not properly sanitize database queries.",
                    parameter
                ),
                evidence: Some(format!("SQL error detected in response: '{}'", detected_error)),
                cwe: "CWE-89".to_string(),
                cvss: 9.8,
                verified: true,
                false_positive: false,
                remediation: "1. Use parameterized queries/prepared statements\n2. Implement input validation and sanitization\n3. Apply principle of least privilege for database accounts\n4. Use an ORM framework".to_string(),
                discovered_at: Utc::now().to_rfc3339(),
                ml_data: None,
            });
        }

        // For MEDIUM-CONFIDENCE errors, require additional context validation
        let has_medium_confidence_error = medium_confidence_errors.iter().any(|pattern| {
            response_lower.contains(pattern) && !baseline_lower.contains(pattern)
        });

        if has_medium_confidence_error {
            // Additional validation: check if we're NOT in a false-positive context
            // False positive contexts: tutorials, documentation, articles, code examples
            let fp_indicators = [
                "<article",
                "<pre>",
                "<code>",
                "class=\"tutorial",
                "class=\"example",
                "class=\"documentation",
                "class=\"post-content",
                "class=\"highlight",
                "class=\"language-",
                "stackoverflow.com",
                "github.com",
                "how to fix",
                "common error",
                "troubleshooting",
            ];

            let is_likely_false_positive = fp_indicators.iter().any(|fp| {
                response_lower.contains(fp)
            });

            // Also check if the error appears in a likely error context
            let error_context_indicators = [
                "exception",
                "stack trace",
                "backtrace",
                "fatal",
                "warning:",
                "error:",
                "<br>",
            ];

            let has_error_context = error_context_indicators.iter().any(|ctx| {
                response_lower.contains(ctx)
            });

            // Only report if we have error context AND we're not in a FP context
            if has_error_context && !is_likely_false_positive {
                let detected_error = medium_confidence_errors
                    .iter()
                    .find(|pattern| {
                        response_lower.contains(*pattern) && !baseline_lower.contains(*pattern)
                    })
                    .map(|s| s.to_string())
                    .unwrap_or_else(|| "SQL error pattern".to_string());

                return Some(Vulnerability {
                    id: format!("sqli_{}", uuid::Uuid::new_v4().to_string()),
                    vuln_type: "SQL Injection".to_string(),
                    severity: Severity::Critical,
                    confidence: Confidence::Medium, // Lower confidence for medium patterns
                    category: "Injection".to_string(),
                    url: url.to_string(),
                    parameter: Some(parameter.to_string()),
                    payload: payload.to_string(),
                    description: format!(
                        "SQL injection vulnerability detected in parameter '{}'. The application does not properly sanitize database queries.",
                        parameter
                    ),
                    evidence: Some(format!("SQL error detected in response: '{}'", detected_error)),
                    cwe: "CWE-89".to_string(),
                    cvss: 9.8,
                    verified: true,
                    false_positive: false,
                    remediation: "1. Use parameterized queries/prepared statements\n2. Implement input validation and sanitization\n3. Apply principle of least privilege for database accounts\n4. Use an ORM framework".to_string(),
                    discovered_at: Utc::now().to_rfc3339(),
                    ml_data: None,
                });
            }
        }

        None
    }

    /// Detect command injection vulnerability
    pub fn detect_command_injection(
        &self,
        url: &str,
        parameter: &str,
        payload: &str,
        response: &HttpResponse,
    ) -> Option<Vulnerability> {
        // Command execution indicators
        let command_indicators = vec![
            "root:",
            "daemon:",
            "/bin/",
            "/usr/bin/",
            "uid=",
            "gid=",
            "groups=",
        ];

        let has_command_output = command_indicators
            .iter()
            .any(|pattern| response.body.contains(pattern));

        if !has_command_output {
            return None;
        }

        Some(Vulnerability {
            id: format!("cmdi_{}", uuid::Uuid::new_v4().to_string()),
            vuln_type: "Command Injection".to_string(),
            severity: Severity::Critical,
            confidence: Confidence::High,
            category: "Injection".to_string(),
            url: url.to_string(),
            parameter: Some(parameter.to_string()),
            payload: payload.to_string(),
            description: format!(
                "Command injection vulnerability detected in parameter '{}'. The application allows execution of arbitrary system commands.",
                parameter
            ),
            evidence: Some("System command output detected in response".to_string()),
            cwe: "CWE-78".to_string(),
            cvss: 9.8,
            verified: true,
            false_positive: false,
            remediation: "1. Avoid executing system commands with user input\n2. Use parameterized APIs when possible\n3. Implement strict input validation\n4. Use allowlists for permitted commands".to_string(),
            discovered_at: Utc::now().to_rfc3339(),
            ml_data: None,
        })
    }
}

// Add uuid crate for generating IDs
mod uuid {
    use rand::Rng;

    pub struct Uuid;

    impl Uuid {
        pub fn new_v4() -> Self {
            Self
        }

        pub fn to_string(&self) -> String {
            let mut rng = rand::rng();
            format!(
                "{:08x}-{:04x}-{:04x}-{:04x}-{:012x}",
                rng.random::<u32>(),
                rng.random::<u16>(),
                rng.random::<u16>(),
                rng.random::<u16>(),
                rng.random::<u64>() & 0xffffffffffff
            )
        }
    }
}
