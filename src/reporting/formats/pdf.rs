// Copyright (c) 2025 Bountyy Oy. All rights reserved.
// This software is proprietary and confidential.

use crate::reporting::types::{BrandingConfig, EnhancedReport};
use crate::types::Severity;
use anyhow::Result;
use printpdf::*;

pub struct PdfReportGenerator;

impl PdfReportGenerator {
    pub fn new() -> Self {
        Self
    }

    pub async fn generate(&self, report: &EnhancedReport, branding: &BrandingConfig) -> Result<Vec<u8>> {
        // Create PDF document using new API
        let mut doc = PdfDocument::new(&format!("Security Report - {}", report.executive_summary.target));

        // Build all pages with operations
        let mut pages = Vec::new();
        let mut current_ops = Vec::new();
        let mut y_pos = 270.0_f32; // Using Mm coordinates
        let left_margin = 20.0_f32;

        // Title page content
        current_ops.push(Op::StartTextSection);

        // Title
        current_ops.push(Op::SetTextCursor { pos: Point::new(Mm(left_margin), Mm(y_pos)) });
        current_ops.push(Op::SetFontSizeBuiltinFont { font: BuiltinFont::HelveticaBold, size: Pt(24.0) });
        current_ops.push(Op::WriteTextBuiltinFont {
            items: vec![TextItem::Text(branding.report_title.as_ref().unwrap_or(&"Security Assessment Report".to_string()).clone())],
            font: BuiltinFont::HelveticaBold,
        });
        y_pos -= 10.0;

        // Target
        current_ops.push(Op::SetTextCursor { pos: Point::new(Mm(left_margin), Mm(y_pos)) });
        current_ops.push(Op::SetFontSizeBuiltinFont { font: BuiltinFont::Helvetica, size: Pt(12.0) });
        current_ops.push(Op::WriteTextBuiltinFont {
            items: vec![TextItem::Text(format!("Target: {}", report.executive_summary.target))],
            font: BuiltinFont::Helvetica,
        });
        y_pos -= 6.0;

        // Scan Date
        current_ops.push(Op::SetTextCursor { pos: Point::new(Mm(left_margin), Mm(y_pos)) });
        current_ops.push(Op::WriteTextBuiltinFont {
            items: vec![TextItem::Text(format!("Scan Date: {}", report.executive_summary.scan_date))],
            font: BuiltinFont::Helvetica,
        });
        y_pos -= 6.0;

        // Company
        current_ops.push(Op::SetTextCursor { pos: Point::new(Mm(left_margin), Mm(y_pos)) });
        current_ops.push(Op::WriteTextBuiltinFont {
            items: vec![TextItem::Text(format!("Generated by: {}", branding.company_name))],
            font: BuiltinFont::Helvetica,
        });
        y_pos -= 12.0;

        // Executive Summary Header
        current_ops.push(Op::SetTextCursor { pos: Point::new(Mm(left_margin), Mm(y_pos)) });
        current_ops.push(Op::SetFontSizeBuiltinFont { font: BuiltinFont::HelveticaBold, size: Pt(14.0) });
        current_ops.push(Op::WriteTextBuiltinFont {
            items: vec![TextItem::Text("EXECUTIVE SUMMARY".to_string())],
            font: BuiltinFont::HelveticaBold,
        });
        y_pos -= 8.0;

        // Risk Level
        let risk_color = self.get_risk_color_rgb(&report.executive_summary.risk_level);
        current_ops.push(Op::SetFillColor { col: Color::Rgb(risk_color) });
        current_ops.push(Op::SetTextCursor { pos: Point::new(Mm(left_margin), Mm(y_pos)) });
        current_ops.push(Op::SetFontSizeBuiltinFont { font: BuiltinFont::HelveticaBold, size: Pt(11.0) });
        current_ops.push(Op::WriteTextBuiltinFont {
            items: vec![TextItem::Text(format!("Risk Level: {} (Score: {:.1})",
                report.executive_summary.risk_level,
                report.executive_summary.risk_score))],
            font: BuiltinFont::HelveticaBold,
        });
        current_ops.push(Op::SetFillColor { col: Color::Rgb(Rgb { r: 0.0, g: 0.0, b: 0.0, icc_profile: None }) });
        y_pos -= 8.0;

        // Total Vulnerabilities
        current_ops.push(Op::SetTextCursor { pos: Point::new(Mm(left_margin), Mm(y_pos)) });
        current_ops.push(Op::SetFontSizeBuiltinFont { font: BuiltinFont::Helvetica, size: Pt(10.0) });
        current_ops.push(Op::WriteTextBuiltinFont {
            items: vec![TextItem::Text(format!("Total Vulnerabilities: {}", report.executive_summary.total_vulnerabilities))],
            font: BuiltinFont::Helvetica,
        });
        y_pos -= 6.0;

        // Severity Breakdown
        let severity_text = format!(
            "Critical: {} | High: {} | Medium: {} | Low: {} | Info: {}",
            report.executive_summary.critical_count,
            report.executive_summary.high_count,
            report.executive_summary.medium_count,
            report.executive_summary.low_count,
            report.executive_summary.info_count
        );
        current_ops.push(Op::SetTextCursor { pos: Point::new(Mm(left_margin), Mm(y_pos)) });
        current_ops.push(Op::WriteTextBuiltinFont {
            items: vec![TextItem::Text(severity_text)],
            font: BuiltinFont::Helvetica,
        });
        y_pos -= 6.0;

        // Duration
        current_ops.push(Op::SetTextCursor { pos: Point::new(Mm(left_margin), Mm(y_pos)) });
        current_ops.push(Op::WriteTextBuiltinFont {
            items: vec![TextItem::Text(format!("Scan Duration: {:.1} seconds", report.executive_summary.duration_seconds))],
            font: BuiltinFont::Helvetica,
        });
        y_pos -= 12.0;

        // Key Findings
        if !report.executive_summary.key_findings.is_empty() {
            current_ops.push(Op::SetTextCursor { pos: Point::new(Mm(left_margin), Mm(y_pos)) });
            current_ops.push(Op::SetFontSizeBuiltinFont { font: BuiltinFont::HelveticaBold, size: Pt(12.0) });
            current_ops.push(Op::WriteTextBuiltinFont {
                items: vec![TextItem::Text("KEY FINDINGS".to_string())],
                font: BuiltinFont::HelveticaBold,
            });
            y_pos -= 6.0;

            current_ops.push(Op::SetFontSizeBuiltinFont { font: BuiltinFont::Helvetica, size: Pt(9.0) });
            for finding in report.executive_summary.key_findings.iter().take(5) {
                let truncated = self.truncate(finding, 90);
                current_ops.push(Op::SetTextCursor { pos: Point::new(Mm(left_margin + 5.0), Mm(y_pos)) });
                current_ops.push(Op::WriteTextBuiltinFont {
                    items: vec![TextItem::Text(format!("* {}", truncated))],
                    font: BuiltinFont::Helvetica,
                });
                y_pos -= 5.0;
            }
            y_pos -= 6.0;
        }

        // Vulnerability Details Header
        current_ops.push(Op::SetTextCursor { pos: Point::new(Mm(left_margin), Mm(y_pos)) });
        current_ops.push(Op::SetFontSizeBuiltinFont { font: BuiltinFont::HelveticaBold, size: Pt(14.0) });
        current_ops.push(Op::WriteTextBuiltinFont {
            items: vec![TextItem::Text("VULNERABILITY DETAILS".to_string())],
            font: BuiltinFont::HelveticaBold,
        });
        y_pos -= 8.0;

        current_ops.push(Op::EndTextSection);

        // Add vulnerabilities
        for (idx, vuln) in report.scan_results.vulnerabilities.iter().enumerate() {
            // Check if we need a new page
            if y_pos < 40.0 {
                pages.push(PdfPage::new(Mm(210.0), Mm(297.0), current_ops));
                current_ops = Vec::new();
                y_pos = 270.0;

                current_ops.push(Op::StartTextSection);
                current_ops.push(Op::SetTextCursor { pos: Point::new(Mm(left_margin), Mm(y_pos)) });
                current_ops.push(Op::SetFontSizeBuiltinFont { font: BuiltinFont::HelveticaBold, size: Pt(12.0) });
                current_ops.push(Op::WriteTextBuiltinFont {
                    items: vec![TextItem::Text("VULNERABILITY DETAILS (continued)".to_string())],
                    font: BuiltinFont::HelveticaBold,
                });
                y_pos -= 10.0;
            } else {
                current_ops.push(Op::StartTextSection);
            }

            // Vulnerability title with severity color
            let severity_color = self.get_severity_color_rgb(&vuln.severity);
            current_ops.push(Op::SetFillColor { col: Color::Rgb(severity_color) });
            current_ops.push(Op::SetTextCursor { pos: Point::new(Mm(left_margin), Mm(y_pos)) });
            current_ops.push(Op::SetFontSizeBuiltinFont { font: BuiltinFont::HelveticaBold, size: Pt(10.0) });
            current_ops.push(Op::WriteTextBuiltinFont {
                items: vec![TextItem::Text(format!("#{} [{}] {}", idx + 1, vuln.severity, self.truncate(&vuln.vuln_type, 55)))],
                font: BuiltinFont::HelveticaBold,
            });
            current_ops.push(Op::SetFillColor { col: Color::Rgb(Rgb { r: 0.0, g: 0.0, b: 0.0, icc_profile: None }) });
            y_pos -= 5.0;

            // URL
            current_ops.push(Op::SetTextCursor { pos: Point::new(Mm(left_margin + 5.0), Mm(y_pos)) });
            current_ops.push(Op::SetFontSizeBuiltinFont { font: BuiltinFont::Helvetica, size: Pt(8.0) });
            current_ops.push(Op::WriteTextBuiltinFont {
                items: vec![TextItem::Text(format!("URL: {}", self.truncate(&vuln.url, 75)))],
                font: BuiltinFont::Helvetica,
            });
            y_pos -= 4.0;

            // CWE/CVSS
            current_ops.push(Op::SetTextCursor { pos: Point::new(Mm(left_margin + 5.0), Mm(y_pos)) });
            current_ops.push(Op::WriteTextBuiltinFont {
                items: vec![TextItem::Text(format!("CWE: {} | CVSS: {:.1}", vuln.cwe, vuln.cvss))],
                font: BuiltinFont::Helvetica,
            });
            y_pos -= 4.0;

            // Payload
            if !vuln.payload.is_empty() {
                current_ops.push(Op::SetTextCursor { pos: Point::new(Mm(left_margin + 5.0), Mm(y_pos)) });
                current_ops.push(Op::WriteTextBuiltinFont {
                    items: vec![TextItem::Text(format!("Payload: {}", self.truncate(&vuln.payload, 75)))],
                    font: BuiltinFont::Helvetica,
                });
                y_pos -= 4.0;
            }

            // Description
            current_ops.push(Op::SetTextCursor { pos: Point::new(Mm(left_margin + 5.0), Mm(y_pos)) });
            current_ops.push(Op::WriteTextBuiltinFont {
                items: vec![TextItem::Text(format!("Desc: {}", self.truncate(&vuln.description, 80)))],
                font: BuiltinFont::Helvetica,
            });
            y_pos -= 4.0;

            // Remediation
            current_ops.push(Op::SetTextCursor { pos: Point::new(Mm(left_margin + 5.0), Mm(y_pos)) });
            current_ops.push(Op::WriteTextBuiltinFont {
                items: vec![TextItem::Text(format!("Fix: {}", self.truncate(&vuln.remediation, 80)))],
                font: BuiltinFont::Helvetica,
            });
            y_pos -= 8.0;

            current_ops.push(Op::EndTextSection);
        }

        // Footer
        if let Some(footer) = &branding.footer_text {
            current_ops.push(Op::StartTextSection);
            current_ops.push(Op::SetTextCursor { pos: Point::new(Mm(left_margin), Mm(10.0)) });
            current_ops.push(Op::SetFontSizeBuiltinFont { font: BuiltinFont::Helvetica, size: Pt(8.0) });
            current_ops.push(Op::WriteTextBuiltinFont {
                items: vec![TextItem::Text(footer.clone())],
                font: BuiltinFont::Helvetica,
            });
            current_ops.push(Op::EndTextSection);
        }

        // Add last page
        pages.push(PdfPage::new(Mm(210.0), Mm(297.0), current_ops));

        // Generate PDF bytes
        let mut warnings = Vec::new();
        let buffer = doc.with_pages(pages).save(&PdfSaveOptions::default(), &mut warnings);

        Ok(buffer)
    }

    fn get_severity_color_rgb(&self, severity: &Severity) -> Rgb {
        match severity {
            Severity::Critical => Rgb { r: 0.8, g: 0.0, b: 0.0, icc_profile: None },
            Severity::High => Rgb { r: 1.0, g: 0.4, b: 0.0, icc_profile: None },
            Severity::Medium => Rgb { r: 0.8, g: 0.6, b: 0.0, icc_profile: None },
            Severity::Low => Rgb { r: 0.0, g: 0.6, b: 0.0, icc_profile: None },
            Severity::Info => Rgb { r: 0.3, g: 0.3, b: 0.3, icc_profile: None },
        }
    }

    fn get_risk_color_rgb(&self, risk_level: &str) -> Rgb {
        match risk_level.to_lowercase().as_str() {
            "critical" => Rgb { r: 0.8, g: 0.0, b: 0.0, icc_profile: None },
            "high" => Rgb { r: 1.0, g: 0.4, b: 0.0, icc_profile: None },
            "medium" => Rgb { r: 0.8, g: 0.6, b: 0.0, icc_profile: None },
            "low" => Rgb { r: 0.0, g: 0.6, b: 0.0, icc_profile: None },
            _ => Rgb { r: 0.3, g: 0.3, b: 0.3, icc_profile: None },
        }
    }

    fn truncate(&self, s: &str, max_len: usize) -> String {
        if s.len() > max_len {
            format!("{}...", &s[..max_len.saturating_sub(3)])
        } else {
            s.to_string()
        }
    }
}

impl Default for PdfReportGenerator {
    fn default() -> Self {
        Self::new()
    }
}
