// Copyright (c) 2025 Bountyy Oy. All rights reserved.
// This software is proprietary and confidential.

use crate::reporting::types::{BrandingConfig, EnhancedReport};
use crate::types::Severity;
use anyhow::Result;
use printpdf::*;

pub struct PdfReportGenerator;

impl PdfReportGenerator {
    pub fn new() -> Self {
        Self
    }

    pub async fn generate(&self, report: &EnhancedReport, branding: &BrandingConfig) -> Result<Vec<u8>> {
        // Create PDF document using new API
        let mut doc = PdfDocument::new(&format!("Security Report - {}", report.executive_summary.target));

        // Build all pages with operations
        let mut pages = Vec::new();
        let mut current_ops = Vec::new();
        let mut y_pos = 270.0_f32; // Using Mm coordinates
        let left_margin = 20.0_f32;
        let page_bottom = 30.0_f32; // More margin at bottom
        let line_height_small = 5.0_f32;
        let line_height_medium = 7.0_f32;
        let line_height_large = 10.0_f32;
        let section_gap = 15.0_f32;
        let page_width = 210.0_f32;
        let page_height = 297.0_f32;

        // Helper to estimate space needed for a vulnerability entry
        // Title (7) + URL (7) + Category (7) + CVSS (7) + Desc header (7) + 3 desc lines (21) + Remed header (7) + 3 remed lines (21) + spacing (10) = ~94
        let vuln_height = 95.0_f32;

        // Add watermark to first page
        self.add_watermark(&mut current_ops, page_width, page_height);

        // Title page content
        current_ops.push(Op::StartTextSection);

        // Title
        current_ops.push(Op::SetTextCursor { pos: Point::new(Mm(left_margin), Mm(y_pos)) });
        current_ops.push(Op::SetFontSizeBuiltinFont { font: BuiltinFont::HelveticaBold, size: Pt(24.0) });
        current_ops.push(Op::WriteTextBuiltinFont {
            items: vec![TextItem::Text(branding.report_title.as_ref().unwrap_or(&"Security Assessment Report".to_string()).clone())],
            font: BuiltinFont::HelveticaBold,
        });
        y_pos -= line_height_large * 2.5;

        // Target
        current_ops.push(Op::SetTextCursor { pos: Point::new(Mm(left_margin), Mm(y_pos)) });
        current_ops.push(Op::SetFontSizeBuiltinFont { font: BuiltinFont::Helvetica, size: Pt(12.0) });
        current_ops.push(Op::WriteTextBuiltinFont {
            items: vec![TextItem::Text(format!("Target: {}", report.executive_summary.target))],
            font: BuiltinFont::Helvetica,
        });
        y_pos -= line_height_medium;

        // Scan ID
        current_ops.push(Op::SetTextCursor { pos: Point::new(Mm(left_margin), Mm(y_pos)) });
        current_ops.push(Op::WriteTextBuiltinFont {
            items: vec![TextItem::Text(format!("Scan ID: {}", report.scan_results.scan_id))],
            font: BuiltinFont::Helvetica,
        });
        y_pos -= line_height_medium;

        // Scan Date
        current_ops.push(Op::SetTextCursor { pos: Point::new(Mm(left_margin), Mm(y_pos)) });
        current_ops.push(Op::WriteTextBuiltinFont {
            items: vec![TextItem::Text(format!("Scan Date: {}", report.executive_summary.scan_date))],
            font: BuiltinFont::Helvetica,
        });
        y_pos -= line_height_medium;

        // Company
        current_ops.push(Op::SetTextCursor { pos: Point::new(Mm(left_margin), Mm(y_pos)) });
        current_ops.push(Op::WriteTextBuiltinFont {
            items: vec![TextItem::Text(format!("Generated by: {}", branding.company_name))],
            font: BuiltinFont::Helvetica,
        });
        y_pos -= section_gap * 1.5;

        // Section separator - just add spacing
        y_pos -= section_gap;

        // Executive Summary Header
        current_ops.push(Op::SetTextCursor { pos: Point::new(Mm(left_margin), Mm(y_pos)) });
        current_ops.push(Op::SetFontSizeBuiltinFont { font: BuiltinFont::HelveticaBold, size: Pt(18.0) });
        current_ops.push(Op::SetFillColor { col: Color::Rgb(Rgb { r: 0.2, g: 0.8, b: 0.1, icc_profile: None }) });
        current_ops.push(Op::WriteTextBuiltinFont {
            items: vec![TextItem::Text("EXECUTIVE SUMMARY".to_string())],
            font: BuiltinFont::HelveticaBold,
        });
        current_ops.push(Op::SetFillColor { col: Color::Rgb(Rgb { r: 0.0, g: 0.0, b: 0.0, icc_profile: None }) });
        y_pos -= line_height_large * 1.5;

        // Risk Level with color
        let risk_color = self.get_risk_color_rgb(&report.executive_summary.risk_level);
        current_ops.push(Op::SetFillColor { col: Color::Rgb(risk_color) });
        current_ops.push(Op::SetTextCursor { pos: Point::new(Mm(left_margin), Mm(y_pos)) });
        current_ops.push(Op::SetFontSizeBuiltinFont { font: BuiltinFont::HelveticaBold, size: Pt(14.0) });
        current_ops.push(Op::WriteTextBuiltinFont {
            items: vec![TextItem::Text(format!("Overall Risk: {} (Score: {:.1}/10.0)",
                report.executive_summary.risk_level,
                report.executive_summary.risk_score))],
            font: BuiltinFont::HelveticaBold,
        });
        current_ops.push(Op::SetFillColor { col: Color::Rgb(Rgb { r: 0.0, g: 0.0, b: 0.0, icc_profile: None }) });
        y_pos -= line_height_large * 1.5;

        // Total Vulnerabilities
        current_ops.push(Op::SetTextCursor { pos: Point::new(Mm(left_margin), Mm(y_pos)) });
        current_ops.push(Op::SetFontSizeBuiltinFont { font: BuiltinFont::HelveticaBold, size: Pt(12.0) });
        current_ops.push(Op::WriteTextBuiltinFont {
            items: vec![TextItem::Text(format!("Total Vulnerabilities Found: {}", report.executive_summary.total_vulnerabilities))],
            font: BuiltinFont::HelveticaBold,
        });
        y_pos -= line_height_medium * 1.5;

        // Severity Breakdown - show each severity with its color
        current_ops.push(Op::SetFontSizeBuiltinFont { font: BuiltinFont::Helvetica, size: Pt(11.0) });

        // Critical
        current_ops.push(Op::SetFillColor { col: Color::Rgb(self.get_severity_color_rgb(&Severity::Critical)) });
        current_ops.push(Op::SetTextCursor { pos: Point::new(Mm(left_margin), Mm(y_pos)) });
        current_ops.push(Op::WriteTextBuiltinFont {
            items: vec![TextItem::Text(format!("Critical: {}", report.executive_summary.critical_count))],
            font: BuiltinFont::Helvetica,
        });

        // High
        current_ops.push(Op::SetFillColor { col: Color::Rgb(self.get_severity_color_rgb(&Severity::High)) });
        current_ops.push(Op::SetTextCursor { pos: Point::new(Mm(left_margin + 35.0), Mm(y_pos)) });
        current_ops.push(Op::WriteTextBuiltinFont {
            items: vec![TextItem::Text(format!("High: {}", report.executive_summary.high_count))],
            font: BuiltinFont::Helvetica,
        });

        // Medium
        current_ops.push(Op::SetFillColor { col: Color::Rgb(self.get_severity_color_rgb(&Severity::Medium)) });
        current_ops.push(Op::SetTextCursor { pos: Point::new(Mm(left_margin + 65.0), Mm(y_pos)) });
        current_ops.push(Op::WriteTextBuiltinFont {
            items: vec![TextItem::Text(format!("Medium: {}", report.executive_summary.medium_count))],
            font: BuiltinFont::Helvetica,
        });

        // Low
        current_ops.push(Op::SetFillColor { col: Color::Rgb(self.get_severity_color_rgb(&Severity::Low)) });
        current_ops.push(Op::SetTextCursor { pos: Point::new(Mm(left_margin + 100.0), Mm(y_pos)) });
        current_ops.push(Op::WriteTextBuiltinFont {
            items: vec![TextItem::Text(format!("Low: {}", report.executive_summary.low_count))],
            font: BuiltinFont::Helvetica,
        });

        // Info
        current_ops.push(Op::SetFillColor { col: Color::Rgb(self.get_severity_color_rgb(&Severity::Info)) });
        current_ops.push(Op::SetTextCursor { pos: Point::new(Mm(left_margin + 130.0), Mm(y_pos)) });
        current_ops.push(Op::WriteTextBuiltinFont {
            items: vec![TextItem::Text(format!("Info: {}", report.executive_summary.info_count))],
            font: BuiltinFont::Helvetica,
        });

        current_ops.push(Op::SetFillColor { col: Color::Rgb(Rgb { r: 0.0, g: 0.0, b: 0.0, icc_profile: None }) });
        y_pos -= line_height_medium * 1.5;

        // Duration
        current_ops.push(Op::SetTextCursor { pos: Point::new(Mm(left_margin), Mm(y_pos)) });
        current_ops.push(Op::SetFontSizeBuiltinFont { font: BuiltinFont::Helvetica, size: Pt(10.0) });
        current_ops.push(Op::WriteTextBuiltinFont {
            items: vec![TextItem::Text(format!("Scan Duration: {:.1} seconds", report.executive_summary.duration_seconds))],
            font: BuiltinFont::Helvetica,
        });
        y_pos -= section_gap;

        // Key Findings
        if !report.executive_summary.key_findings.is_empty() {
            current_ops.push(Op::SetTextCursor { pos: Point::new(Mm(left_margin), Mm(y_pos)) });
            current_ops.push(Op::SetFontSizeBuiltinFont { font: BuiltinFont::HelveticaBold, size: Pt(14.0) });
            current_ops.push(Op::SetFillColor { col: Color::Rgb(Rgb { r: 0.9, g: 0.6, b: 0.0, icc_profile: None }) });
            current_ops.push(Op::WriteTextBuiltinFont {
                items: vec![TextItem::Text("KEY FINDINGS".to_string())],
                font: BuiltinFont::HelveticaBold,
            });
            current_ops.push(Op::SetFillColor { col: Color::Rgb(Rgb { r: 0.0, g: 0.0, b: 0.0, icc_profile: None }) });
            y_pos -= line_height_medium * 1.2;

            current_ops.push(Op::SetFontSizeBuiltinFont { font: BuiltinFont::Helvetica, size: Pt(10.0) });
            for finding in report.executive_summary.key_findings.iter().take(6) {
                let truncated = self.truncate(finding, 85);
                current_ops.push(Op::SetTextCursor { pos: Point::new(Mm(left_margin + 5.0), Mm(y_pos)) });
                current_ops.push(Op::WriteTextBuiltinFont {
                    items: vec![TextItem::Text(format!("* {}", truncated))],
                    font: BuiltinFont::Helvetica,
                });
                y_pos -= line_height_medium;
            }
            y_pos -= line_height_small;
        }

        // Recommendations
        if !report.executive_summary.recommendations.is_empty() {
            current_ops.push(Op::SetTextCursor { pos: Point::new(Mm(left_margin), Mm(y_pos)) });
            current_ops.push(Op::SetFontSizeBuiltinFont { font: BuiltinFont::HelveticaBold, size: Pt(14.0) });
            current_ops.push(Op::SetFillColor { col: Color::Rgb(Rgb { r: 0.2, g: 0.8, b: 0.1, icc_profile: None }) });
            current_ops.push(Op::WriteTextBuiltinFont {
                items: vec![TextItem::Text("RECOMMENDATIONS".to_string())],
                font: BuiltinFont::HelveticaBold,
            });
            current_ops.push(Op::SetFillColor { col: Color::Rgb(Rgb { r: 0.0, g: 0.0, b: 0.0, icc_profile: None }) });
            y_pos -= line_height_medium * 1.2;

            current_ops.push(Op::SetFontSizeBuiltinFont { font: BuiltinFont::Helvetica, size: Pt(10.0) });
            for (idx, rec) in report.executive_summary.recommendations.iter().take(5).enumerate() {
                let truncated = self.truncate(rec, 80);
                current_ops.push(Op::SetTextCursor { pos: Point::new(Mm(left_margin + 5.0), Mm(y_pos)) });
                current_ops.push(Op::WriteTextBuiltinFont {
                    items: vec![TextItem::Text(format!("{}. {}", idx + 1, truncated))],
                    font: BuiltinFont::Helvetica,
                });
                y_pos -= line_height_medium;
            }
        }

        current_ops.push(Op::EndTextSection);

        // Start new page for vulnerabilities
        pages.push(PdfPage::new(Mm(page_width), Mm(page_height), current_ops));
        current_ops = Vec::new();
        y_pos = 270.0;

        // Add watermark to vulnerabilities page
        self.add_watermark(&mut current_ops, page_width, page_height);

        // Vulnerability Details Header
        current_ops.push(Op::StartTextSection);
        current_ops.push(Op::SetTextCursor { pos: Point::new(Mm(left_margin), Mm(y_pos)) });
        current_ops.push(Op::SetFontSizeBuiltinFont { font: BuiltinFont::HelveticaBold, size: Pt(18.0) });
        current_ops.push(Op::SetFillColor { col: Color::Rgb(Rgb { r: 0.2, g: 0.8, b: 0.1, icc_profile: None }) });
        current_ops.push(Op::WriteTextBuiltinFont {
            items: vec![TextItem::Text("VULNERABILITY DETAILS".to_string())],
            font: BuiltinFont::HelveticaBold,
        });
        current_ops.push(Op::SetFillColor { col: Color::Rgb(Rgb { r: 0.0, g: 0.0, b: 0.0, icc_profile: None }) });
        y_pos -= section_gap * 1.2;
        current_ops.push(Op::EndTextSection);

        // Add vulnerabilities
        for (idx, vuln) in report.scan_results.vulnerabilities.iter().enumerate() {
            // Check if we need a new page - ensure enough space for full vulnerability entry
            if y_pos < page_bottom + vuln_height {
                pages.push(PdfPage::new(Mm(page_width), Mm(page_height), current_ops));
                current_ops = Vec::new();
                y_pos = 270.0;

                // Add watermark to new page
                self.add_watermark(&mut current_ops, page_width, page_height);

                current_ops.push(Op::StartTextSection);
                current_ops.push(Op::SetTextCursor { pos: Point::new(Mm(left_margin), Mm(y_pos)) });
                current_ops.push(Op::SetFontSizeBuiltinFont { font: BuiltinFont::HelveticaBold, size: Pt(12.0) });
                current_ops.push(Op::SetFillColor { col: Color::Rgb(Rgb { r: 0.2, g: 0.8, b: 0.1, icc_profile: None }) });
                current_ops.push(Op::WriteTextBuiltinFont {
                    items: vec![TextItem::Text(format!("VULNERABILITY DETAILS (Page {})", pages.len() + 1))],
                    font: BuiltinFont::HelveticaBold,
                });
                current_ops.push(Op::SetFillColor { col: Color::Rgb(Rgb { r: 0.0, g: 0.0, b: 0.0, icc_profile: None }) });
                y_pos -= section_gap;
                current_ops.push(Op::EndTextSection);
            }

            current_ops.push(Op::StartTextSection);

            // Vulnerability title with severity color - make it stand out
            let severity_color = self.get_severity_color_rgb(&vuln.severity);
            current_ops.push(Op::SetFillColor { col: Color::Rgb(severity_color) });
            current_ops.push(Op::SetTextCursor { pos: Point::new(Mm(left_margin), Mm(y_pos)) });
            current_ops.push(Op::SetFontSizeBuiltinFont { font: BuiltinFont::HelveticaBold, size: Pt(11.0) });
            current_ops.push(Op::WriteTextBuiltinFont {
                items: vec![TextItem::Text(format!("#{} [{}] {}", idx + 1, vuln.severity, self.truncate(&vuln.vuln_type, 60)))],
                font: BuiltinFont::HelveticaBold,
            });
            current_ops.push(Op::SetFillColor { col: Color::Rgb(Rgb { r: 0.0, g: 0.0, b: 0.0, icc_profile: None }) });
            y_pos -= line_height_medium;

            // URL - full width
            current_ops.push(Op::SetTextCursor { pos: Point::new(Mm(left_margin + 3.0), Mm(y_pos)) });
            current_ops.push(Op::SetFontSizeBuiltinFont { font: BuiltinFont::Helvetica, size: Pt(10.0) });
            current_ops.push(Op::WriteTextBuiltinFont {
                items: vec![TextItem::Text(format!("URL: {}", self.truncate(&vuln.url, 85)))],
                font: BuiltinFont::Helvetica,
            });
            y_pos -= line_height_medium;

            // Parameter if present
            if let Some(param) = &vuln.parameter {
                current_ops.push(Op::SetTextCursor { pos: Point::new(Mm(left_margin + 3.0), Mm(y_pos)) });
                current_ops.push(Op::WriteTextBuiltinFont {
                    items: vec![TextItem::Text(format!("Parameter: {}", param))],
                    font: BuiltinFont::Helvetica,
                });
                y_pos -= line_height_medium;
            }

            // Category and CWE
            current_ops.push(Op::SetTextCursor { pos: Point::new(Mm(left_margin + 3.0), Mm(y_pos)) });
            current_ops.push(Op::WriteTextBuiltinFont {
                items: vec![TextItem::Text(format!("Category: {}  |  CWE: {}", vuln.category, vuln.cwe))],
                font: BuiltinFont::Helvetica,
            });
            y_pos -= line_height_medium;

            // CVSS/Confidence/Verified
            let verified_str = if vuln.verified { "Yes" } else { "No" };
            current_ops.push(Op::SetTextCursor { pos: Point::new(Mm(left_margin + 3.0), Mm(y_pos)) });
            current_ops.push(Op::WriteTextBuiltinFont {
                items: vec![TextItem::Text(format!("CVSS: {:.1}  |  Confidence: {}  |  Verified: {}", vuln.cvss, vuln.confidence, verified_str))],
                font: BuiltinFont::Helvetica,
            });
            y_pos -= line_height_medium;

            // Payload if present
            if !vuln.payload.is_empty() && vuln.payload != "-" {
                current_ops.push(Op::SetTextCursor { pos: Point::new(Mm(left_margin + 3.0), Mm(y_pos)) });
                current_ops.push(Op::SetFontSizeBuiltinFont { font: BuiltinFont::HelveticaBold, size: Pt(10.0) });
                current_ops.push(Op::SetFillColor { col: Color::Rgb(Rgb { r: 0.9, g: 0.6, b: 0.0, icc_profile: None }) });
                current_ops.push(Op::WriteTextBuiltinFont {
                    items: vec![TextItem::Text("Payload/PoC:".to_string())],
                    font: BuiltinFont::HelveticaBold,
                });
                current_ops.push(Op::SetFillColor { col: Color::Rgb(Rgb { r: 0.0, g: 0.0, b: 0.0, icc_profile: None }) });
                y_pos -= line_height_medium;

                current_ops.push(Op::SetFontSizeBuiltinFont { font: BuiltinFont::Helvetica, size: Pt(9.0) });
                let payload_lines = self.wrap_text(&vuln.payload, 90);
                for line in payload_lines.iter().take(2) {
                    current_ops.push(Op::SetTextCursor { pos: Point::new(Mm(left_margin + 6.0), Mm(y_pos)) });
                    current_ops.push(Op::WriteTextBuiltinFont {
                        items: vec![TextItem::Text(line.clone())],
                        font: BuiltinFont::Helvetica,
                    });
                    y_pos -= line_height_medium;
                }
            }

            // Description - wrap to multiple lines
            current_ops.push(Op::SetTextCursor { pos: Point::new(Mm(left_margin + 3.0), Mm(y_pos)) });
            current_ops.push(Op::SetFontSizeBuiltinFont { font: BuiltinFont::HelveticaBold, size: Pt(10.0) });
            current_ops.push(Op::WriteTextBuiltinFont {
                items: vec![TextItem::Text("Description:".to_string())],
                font: BuiltinFont::HelveticaBold,
            });
            y_pos -= line_height_medium;

            current_ops.push(Op::SetFontSizeBuiltinFont { font: BuiltinFont::Helvetica, size: Pt(10.0) });
            let desc_lines = self.wrap_text(&vuln.description, 90);
            for line in desc_lines.iter().take(3) {
                current_ops.push(Op::SetTextCursor { pos: Point::new(Mm(left_margin + 6.0), Mm(y_pos)) });
                current_ops.push(Op::WriteTextBuiltinFont {
                    items: vec![TextItem::Text(line.clone())],
                    font: BuiltinFont::Helvetica,
                });
                y_pos -= line_height_medium;
            }

            // Remediation - wrap to multiple lines
            current_ops.push(Op::SetTextCursor { pos: Point::new(Mm(left_margin + 3.0), Mm(y_pos)) });
            current_ops.push(Op::SetFontSizeBuiltinFont { font: BuiltinFont::HelveticaBold, size: Pt(10.0) });
            current_ops.push(Op::SetFillColor { col: Color::Rgb(Rgb { r: 0.2, g: 0.8, b: 0.1, icc_profile: None }) });
            current_ops.push(Op::WriteTextBuiltinFont {
                items: vec![TextItem::Text("Remediation:".to_string())],
                font: BuiltinFont::HelveticaBold,
            });
            current_ops.push(Op::SetFillColor { col: Color::Rgb(Rgb { r: 0.0, g: 0.0, b: 0.0, icc_profile: None }) });
            y_pos -= line_height_medium;

            current_ops.push(Op::SetFontSizeBuiltinFont { font: BuiltinFont::Helvetica, size: Pt(10.0) });
            let remediation_lines = self.wrap_text(&vuln.remediation, 90);
            for line in remediation_lines.iter().take(3) {
                current_ops.push(Op::SetTextCursor { pos: Point::new(Mm(left_margin + 6.0), Mm(y_pos)) });
                current_ops.push(Op::WriteTextBuiltinFont {
                    items: vec![TextItem::Text(line.clone())],
                    font: BuiltinFont::Helvetica,
                });
                y_pos -= line_height_medium;
            }

            y_pos -= line_height_large;

            // Visual separator between vulnerabilities - skip drawing line, just add spacing
            current_ops.push(Op::EndTextSection);
            y_pos -= line_height_medium;
        }

        // Footer on last page
        current_ops.push(Op::StartTextSection);
        current_ops.push(Op::SetTextCursor { pos: Point::new(Mm(left_margin), Mm(18.0)) });
        current_ops.push(Op::SetFontSizeBuiltinFont { font: BuiltinFont::Helvetica, size: Pt(8.0) });
        if let Some(footer) = &branding.footer_text {
            current_ops.push(Op::WriteTextBuiltinFont {
                items: vec![TextItem::Text(footer.clone())],
                font: BuiltinFont::Helvetica,
            });
        }
        current_ops.push(Op::SetTextCursor { pos: Point::new(Mm(left_margin), Mm(12.0)) });
        current_ops.push(Op::SetFillColor { col: Color::Rgb(Rgb { r: 0.2, g: 0.8, b: 0.1, icc_profile: None }) });
        current_ops.push(Op::WriteTextBuiltinFont {
            items: vec![TextItem::Text("Generated by Lonkero - https://lonkero.bountyy.fi".to_string())],
            font: BuiltinFont::Helvetica,
        });
        current_ops.push(Op::EndTextSection);

        // Add last page
        pages.push(PdfPage::new(Mm(page_width), Mm(page_height), current_ops));

        // Generate PDF bytes
        let mut warnings = Vec::new();
        let buffer = doc.with_pages(pages).save(&PdfSaveOptions::default(), &mut warnings);

        Ok(buffer)
    }

    fn get_severity_color_rgb(&self, severity: &Severity) -> Rgb {
        match severity {
            Severity::Critical => Rgb { r: 0.86, g: 0.2, b: 0.27, icc_profile: None },
            Severity::High => Rgb { r: 0.99, g: 0.49, b: 0.08, icc_profile: None },
            Severity::Medium => Rgb { r: 1.0, g: 0.76, b: 0.03, icc_profile: None },
            Severity::Low => Rgb { r: 0.05, g: 0.79, b: 0.94, icc_profile: None },
            Severity::Info => Rgb { r: 0.22, g: 1.0, b: 0.08, icc_profile: None },
        }
    }

    fn get_risk_color_rgb(&self, risk_level: &str) -> Rgb {
        match risk_level.to_lowercase().as_str() {
            "critical" => Rgb { r: 0.86, g: 0.2, b: 0.27, icc_profile: None },
            "high" => Rgb { r: 0.99, g: 0.49, b: 0.08, icc_profile: None },
            "medium" => Rgb { r: 1.0, g: 0.76, b: 0.03, icc_profile: None },
            "low" => Rgb { r: 0.05, g: 0.79, b: 0.94, icc_profile: None },
            _ => Rgb { r: 0.3, g: 0.3, b: 0.3, icc_profile: None },
        }
    }

    fn truncate(&self, s: &str, max_len: usize) -> String {
        if s.len() > max_len {
            format!("{}...", &s[..max_len.saturating_sub(3)])
        } else {
            s.to_string()
        }
    }

    fn wrap_text(&self, text: &str, max_chars: usize) -> Vec<String> {
        let mut lines = Vec::new();
        let mut current_line = String::new();

        // Clean the text - replace newlines and extra whitespace
        let cleaned = text.replace('\n', " ").replace('\r', " ");

        for word in cleaned.split_whitespace() {
            if current_line.is_empty() {
                current_line = word.to_string();
            } else if current_line.len() + 1 + word.len() <= max_chars {
                current_line.push(' ');
                current_line.push_str(word);
            } else {
                lines.push(current_line);
                current_line = word.to_string();
            }
        }

        if !current_line.is_empty() {
            lines.push(current_line);
        }

        if lines.is_empty() {
            lines.push(String::new());
        }

        lines
    }

    fn add_watermark(&self, ops: &mut Vec<Op>, _page_width: f32, _page_height: f32) {
        // Add watermark at the bottom of the page - very faint, won't interfere with content
        ops.push(Op::StartTextSection);
        ops.push(Op::SetFillColor { col: Color::Rgb(Rgb { r: 0.95, g: 0.95, b: 0.95, icc_profile: None }) });
        ops.push(Op::SetTextCursor { pos: Point::new(Mm(60.0), Mm(25.0)) });
        ops.push(Op::SetFontSizeBuiltinFont { font: BuiltinFont::HelveticaBold, size: Pt(48.0) });
        ops.push(Op::WriteTextBuiltinFont {
            items: vec![TextItem::Text("LONKERO".to_string())],
            font: BuiltinFont::HelveticaBold,
        });
        ops.push(Op::SetFillColor { col: Color::Rgb(Rgb { r: 0.0, g: 0.0, b: 0.0, icc_profile: None }) });
        ops.push(Op::EndTextSection);
    }
}

impl Default for PdfReportGenerator {
    fn default() -> Self {
        Self::new()
    }
}
